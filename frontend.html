

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>The Front End: ReactJS and Redux &mdash; Kvasir 0.0.1 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="Kvasir 0.0.1 documentation" href="index.html"/>
        <link rel="next" title="The Back-End: NodeJS and ExpressJS" href="backend.html"/>
        <link rel="prev" title="Kvasir’s Architecture" href="architecture.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> Kvasir
          

          
          </a>

          
            
            
              <div class="version">
                0.0.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="architecture.html">Kvasir&#8217;s Architecture</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="">The Front End: ReactJS and Redux</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#actions-components-and-reducers">Actions, Components, and Reducers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#general-object-implementation">General Object Implementation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#user-object">User Object</a></li>
<li class="toctree-l3"><a class="reference internal" href="#account-object">Account Object</a></li>
<li class="toctree-l3"><a class="reference internal" href="#withdrawal-object">Withdrawal Object</a></li>
<li class="toctree-l3"><a class="reference internal" href="#checkouts-object">Checkouts Object</a></li>
<li class="toctree-l3"><a class="reference internal" href="#credit-card-object">Credit Card Object</a></li>
<li class="toctree-l3"><a class="reference internal" href="#payer-object">Payer Object</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="backend.html">The Back-End: NodeJS and ExpressJS</a></li>
<li class="toctree-l1"><a class="reference internal" href="middleware.html">The Middleware: Whatever Language You Want</a></li>
<li class="toctree-l1"><a class="reference internal" href="herokudeploy.html">Deploying to Heroku</a></li>
<li class="toctree-l1"><a class="reference internal" href="googleappengine.html">Deploying to Google App Engine</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">Kvasir</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          





<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
    <li>The Front End: ReactJS and Redux</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/frontend.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="the-front-end-reactjs-and-redux">
<span id="kvasirfrontend"></span><h1>The Front End: ReactJS and Redux<a class="headerlink" href="#the-front-end-reactjs-and-redux" title="Permalink to this headline">¶</a></h1>
<p>After <a class="reference internal" href="architecture.html#kvasirarch"><span>completing the architecture</span></a> we began to look at what technologies were available to help us meet our end goal.  Again, we wanted to retain many of the benefits that come with a single page app (SPA) so we began looking at the available SPA frameworks and libraries.</p>
<p>We saw the user-interface being composed of a set of components.  Each componenet had a tie to another component, and an update to the first component would impact the second, but not necessarily all other components.  For example, searching a user should impact the information displayed about that user (the <em>user component</em>) and the since the available account information stems from the user, then this action should also affect what account information is displayed.  Selecting a particular account would allow us to render <em>checkout</em> information about that account, but it shouldn&#8217;t impact the account component itself or the user component.  I can change between a merchant&#8217;s accounts and load the related checkouts for each account without having to reload the entire page.</p>
<p>Essentially, our application should allow a user to walk through their internal database, in combination with WePay lookup calls and other actions, to gather information about a particular merchant or payer and complete tasks for them.</p>
<p><a class="reference external" href="https://facebook.github.io/react/">ReactJS</a> gives us exactly what we were looking for.  The entire philosophy behind React is the idea that a user interface should be composed of a set of independent components.  In our initial prototypes, we had trouble passing around information between components. <a class="reference external" href="http://redux.js.org/">Redux</a> solved the problem for us by making it easier to share information across the application.  We likely could have developed everything purely in React, but Redux made it easier to get off the ground.</p>
<div class="section" id="actions-components-and-reducers">
<h2>Actions, Components, and Reducers<a class="headerlink" href="#actions-components-and-reducers" title="Permalink to this headline">¶</a></h2>
<dl class="docutils">
<dt>React and Redux apps are comprised of 3 parts:</dt>
<dd><ul class="first last">
<li><dl class="first docutils">
<dt>Actions</dt>
<dd><ul class="first last simple">
<li>events that should manipulate the state of the application in some way</li>
<li>also responsible for making POST requests to the back-end and dispatching other actions as a result of those requests</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Reducers</dt>
<dd><ul class="first last simple">
<li>given an action, manipulate the state of the application</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Components</dt>
<dd><ul class="first last simple">
<li>the front-end blocks of dynamic HTML</li>
<li>Take information from different parts of the Redux state object to render on the page.</li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
<p>Holding onto the idea that our application is really taking a user on a walk through their internal database, we have a set of &#8220;objects&#8221; or &#8220;models&#8221;, each of which have their own set of actions, reducers and components.</p>
<dl class="docutils">
<dt>These objects are:</dt>
<dd><ul class="first">
<li><dl class="first docutils">
<dt><a class="reference internal" href="#user-object"><span>User</span></a></dt>
<dd><ul class="first last simple">
<li>represents a given <em>merchant</em>.</li>
<li>A merchant can have multiple accounts.</li>
</ul>
</dd>
</dl>
</li>
</ul>
<blockquote class="last">
<div><ul>
<li><dl class="first docutils">
<dt><a class="reference internal" href="#account-object"><span>Accounts</span></a></dt>
<dd><ul class="first last simple">
<li>represents a merchant account</li>
<li>One account can belong to multiple users, but this is not common</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><a class="reference internal" href="#checkouts-object"><span>Checkouts</span></a></dt>
<dd><ul class="first last simple">
<li>represents the checkouts tied to a given merchant account (Accounts object)</li>
<li>Accounts should have multiple checkouts, but each checkout only belongs to one account.</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><a class="reference internal" href="#withdrawal-object"><span>Withdrawals</span></a></dt>
<dd><ul class="first last simple">
<li>represents the withdrawals tied to a given merchant account</li>
<li>this includes the reserves that an account has</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><a class="reference internal" href="#credit-card-object"><span>Credit Card</span></a></dt>
<dd><ul class="first last simple">
<li>represents the credit card information associated with a given tokenized credit card ID used for a checkout</li>
<li>Tokenized cards can be used for multiple checkouts on the same app, but the information tied to a tokenized card does not change from checkout to checkout</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><a class="reference internal" href="#payer-object"><span>Payer</span></a></dt>
<dd><ul class="first last simple">
<li>represents a payer who made a purchase on the platform</li>
</ul>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
</dd>
</dl>
<p>If you look at these objects, you might recognize that all of these <em>except for the Payer object</em> directly tie back to a WePay API endpoint.  That&#8217;s intentional.  We assumed that many platforms would have developed their database configurations around the different WePay endpoints.  Since you generally have to interact with these endpoints in a certain order (/user endpoint, then /account endpoint, then /checkout endpoint), it makes sense that a partner&#8217;s database would grow around that.  Regardless of how a partner&#8217;s database is configured, Kvasir needs to interact with each of these endpoints to gather the information it needs.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The front-end objects do not make any calls directly to the WePay API.  All of those are done by the back-end server.</p>
</div>
<p>The <em>components</em> are responsible for handling user actions and then dispatching the associated actions.  The are also responsible for subscribing to all of the necessary state information and formatting that data.  While all actions are globally published, not every component relies on all of that info (and they shouldn&#8217;t).</p>
<p>For example, when an account is clicked in the account component, the account component registers that the click happened, manipulates the table, and then dispatches the <em>searchedAccounts</em>, <em>fetchWithdrawalsIfNeeded</em> and <em>fetchCheckoutsIfNeeded</em> actions.  Some of these actions will directly impact the action component causing it to re-render with new info, while others will impact other components forcing them to re-render with the new information.</p>
<div class="section" id="general-object-implementation">
<h3>General Object Implementation<a class="headerlink" href="#general-object-implementation" title="Permalink to this headline">¶</a></h3>
<p>All of the objects are different in the sense that they require different search requirements (user_id, account_id, etc.); however, they are all implemented in very similar ways.</p>
<dl class="docutils">
<dt>Really, what all of the objects require a handful of actions:</dt>
<dd><ol class="first last arabic">
<li><dl class="first docutils">
<dt>Search</dt>
<dd><ul class="first last simple">
<li>Notify all components the object is being <em>searched</em> for and what exactly we are searching for</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Request</dt>
<dd><ul class="first last simple">
<li>notify all components that the resource is being <em>requested</em></li>
<li>make POST request to back-end for more information (which subsequently makes a call to the WePay API and the middleware if necessary)</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Receive</dt>
<dd><ol class="first last loweralpha">
<li><p class="first">If the POST request completes successfully, then we notify all components that new information has been received</p>
</li>
<li><dl class="first docutils">
<dt>Error</dt>
<dd><ul class="first last simple">
<li>If the POST request did complete successfully, then we notify all components of the error</li>
</ul>
</dd>
</dl>
</li>
</ol>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Clear</dt>
<dd><ul class="first last simple">
<li>Notify all components that we are starting over and need to clear any previously held information because it is no longer valid</li>
</ul>
</dd>
</dl>
</li>
</ol>
</dd>
</dl>
<p>But not all of these actions are directly accessible.  For example, request and receive are always bundled together.</p>
<dl class="docutils">
<dt>In general, these are the public functions that each object has for dispatching actions:</dt>
<dd><ol class="first last arabic">
<li><dl class="function">
<dt id="search">
<code class="descname">search</code><span class="sig-paren">(</span><em>id</em><span class="sig-paren">)</span><a class="headerlink" href="#search" title="Permalink to this definition">¶</a></dt>
<dd><p>Will cause the associated reducer to update its state with the information the user passed in order to search the object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first last simple">
<li><strong>id</strong> &#8211; some unique id of the object that we just looked up.  For example, for user&#8217;s this is an email address; accounts use an account_id</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</li>
<li><dl class="function">
<dt id="fetchIfNeeded">
<code class="descname">fetchIfNeeded</code><span class="sig-paren">(</span><em>id</em><span class="sig-paren">)</span><a class="headerlink" href="#fetchIfNeeded" title="Permalink to this definition">¶</a></dt>
<dd><p>First checks to make sure that we have all the information that we need in order to fetch information.
Then calls the <code class="docutils literal"><span class="pre">fetch()</span></code> function which will make the call to the back-end for more info.
This will result in the dispatching of the <em>request</em> action along with <em>receive</em> or <em>error</em> depending on the result</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first last simple">
<li><strong>id</strong> &#8211; some unique id of the object that we just looked up.  For example, for user&#8217;s this is an email address; accounts use an account_id</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</li>
</ol>
</dd>
</dl>
<p>The reducers that take these actions are also very similar.
Each reducer is actually composed of two smaller reducers - a <em>searched</em> reducer and a <em>base</em> reducer.
We do this because of the asynchronous nature of Redux actions mixed with the POST requests to our back-end.  If someone searches a user, but then realizes they searched the wrong email and changes the search parameter, we need a way to handle that.</p>
<dl class="docutils">
<dt>These two reducers are:</dt>
<dd><ol class="first last arabic">
<li><dl class="function">
<dt id="searched">
<code class="descname">searched</code><span class="sig-paren">(</span><em>state ={}</em>, <em>action</em><span class="sig-paren">)</span><a class="headerlink" href="#searched" title="Permalink to this definition">¶</a></dt>
<dd><p>When a search action fires, update the object&#8217;s state with the information we used to search (account_id, user&#8217;s email, etc).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first last simple">
<li><strong>state</strong> &#8211; The current state of searches made for the object.  The initial state is an empty object because we haven&#8217;t looked anything up yet</li>
<li><strong>action</strong> &#8211; the action that was fired and contains information about the search</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</li>
<li><dl class="function">
<dt id="base">
<code class="descname">base</code><span class="sig-paren">(</span><em>state=defaultState</em>, <em>action</em><span class="sig-paren">)</span><a class="headerlink" href="#base" title="Permalink to this definition">¶</a></dt>
<dd><p>For all other actions other than searching, they are sent to the base reducer.
Responsibly for modifying the information that we maintain for a given searched object
The initial state is defined by each object but generally they all look this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">defaultState</span> <span class="o">=</span> <span class="p">{</span>
<span class="gp">&gt;&gt;&gt; </span>   <span class="n">isFetching</span><span class="p">:</span> <span class="n">false</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>   <span class="n">info</span><span class="p">:</span> <span class="p">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">}</span>
</pre></div>
</div>
<ul class="simple">
<li><em>isFetching</em> tells us if we are waiting for a response</li>
<li><em>info</em> is where the response data is stored</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first last simple">
<li><strong>state</strong> &#8211; the current state of the object.  This includes the information that we requested from the Kvasir&#8217;s back-end.</li>
<li><strong>action</strong> &#8211; the action that was fired that contains information about the object</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</li>
</ol>
</dd>
</dl>
<p>Going back to the early example, if someone were to search a user with one email and immediately change the search parameters, there is no way for them to cancel the original request.  It has likely already been sent to the back-end to be processed.  There is also no guarantee that the first request will finish before the second request.  So, the user may be handed information from the original request, despite the fact that they didn&#8217;t want to.  Separating the search information from the object&#8217;s information that we receive allows Kvasir to validate that the information we received is actually the info we wanted.  If it&#8217;s not, we can ignore it and prevent the state from being updated with unwanted info.</p>
</div>
<div class="section" id="user-object">
<span id="id1"></span><h3>User Object<a class="headerlink" href="#user-object" title="Permalink to this headline">¶</a></h3>
<p>The user objects represents a WePay merchant accessible through the <a class="reference external" href="https://stage.wepay.com/developer/reference/user#lookup">/user</a> endpoint.
This is the primary building block for all other information that we gather.</p>
<p>To gather most information via the WePay API, you need to know the merchant&#8217;s access token.  This has to be stored in the platform&#8217;s database, and is likely tied to the merchant&#8217;s login credentials (such as their email).  So given a merchant&#8217;s email, we can find their access token in the partner database, and then get their information from the WePay API.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The back-end server also supports the ability to find a merchant&#8217;s access token by the account_id as this is sometimes a more readily available key then the merchant&#8217;s user_id or email.</p>
</div>
<dl class="docutils">
<dt>The user&#8217;s information is displayed in a table with a single row that lists:</dt>
<dd><ul class="first last simple">
<li>Email</li>
<li>First Name</li>
<li>Last Name</li>
<li>State</li>
<li>User Id</li>
</ul>
</dd>
</dl>
<p>The state of the user is important because if the user is not in the <em>registered</em> state, then they have not yet confirmed their email on WePay.  It is possible that the confirmation email is lost in the merchant&#8217;s inbox, so Kvasir provides the functionality to resend the confirmation if the user is not <em>registered</em>.</p>
</div>
<div class="section" id="account-object">
<span id="id2"></span><h3>Account Object<a class="headerlink" href="#account-object" title="Permalink to this headline">¶</a></h3>
<p>As soon we have a user&#8217;s access token, we can also get a list of all of their merchant accounts tied to the app_id that the access token is associated with via the <a class="reference external" href="https://stage.wepay.com/developer/reference/account#find">/account/find</a> call.</p>
<p>A user could have multiple accounts, so each account is displayed as a row in a larger table. Clicking on a row of the table will cause the row to become highlighted, and will dispatch actions to fetch more information about that specific account.  This information includes withdrawals, reserves, and checkouts.</p>
<dl class="docutils">
<dt>The account table itself includes:</dt>
<dd><ul class="first last">
<li><dl class="first docutils">
<dt>Account Name</dt>
<dd><ul class="first last simple">
<li>name of the account</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Account Id</dt>
<dd><ul class="first last simple">
<li>accounts unique id</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Balance</dt>
<dd><ul class="first last simple">
<li>how much the account currently has sitting in it.</li>
<li><strong>Note</strong> this is not the lifetime balance of the account</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Bank</dt>
<dd><ul class="first last simple">
<li>If the user has completed KYC, then this is name and last four digits of their bank account</li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</div>
<div class="section" id="withdrawal-object">
<span id="id3"></span><h3>Withdrawal Object<a class="headerlink" href="#withdrawal-object" title="Permalink to this headline">¶</a></h3>
<p>The withdrawal object represents information gained from the <a class="reference external" href="https://stage.wepay.com/developer/reference/withdrawal#lookup">/withdrawal</a> endpoint.
This includes information about where a merchant&#8217;s money is being withdrawn too, when it&#8217;s being withdrawn, and how much is being withdrawn.</p>
<p>It also manages another table detailing the reserves associated with an account if applicable. They are in two different tables, but once you have enough information to get withdrawals, you have enough to get reserves, and they are closely related enough that gathering both at the same time makes sense.</p>
<p>These tables will render the 50 most recent withdrawals/reserves for a merchant.  The actions to gather this information are generally dispatched after an account is selected.  They can be dispatched sooner, but withdrawals are tied to a specific account, so you need both an access_token and an account_id to complete the request.</p>
</div>
<div class="section" id="checkouts-object">
<span id="id4"></span><h3>Checkouts Object<a class="headerlink" href="#checkouts-object" title="Permalink to this headline">¶</a></h3>
<p>The checkout object is one of the more intensive objects.  Since it is the heart of many operations that a platform performs, there are also several actions tied to any given checkout.</p>
<dl class="docutils">
<dt>The checkout component renders a table of information gathered from a <a class="reference external" href="https://stage.wepay.com/developer/reference/checkout#find">/checkout/find</a> call which includes:</dt>
<dd><ul class="first last">
<li><p class="first">Checkout ID</p>
</li>
<li><p class="first">Date</p>
</li>
<li><p class="first">Descriptor</p>
</li>
<li><p class="first">Amount</p>
</li>
<li><dl class="first docutils">
<dt>Gross Amount</dt>
<dd><ul class="first last simple">
<li>the amount + any additional fees that the <em>payer</em> had to pay</li>
</ul>
</dd>
</dl>
</li>
<li><p class="first">Payer Email</p>
</li>
<li><p class="first">Payer Name</p>
</li>
<li><p class="first">Payment Method ID</p>
</li>
</ul>
</dd>
</dl>
<p>The last column of the checkouts table is the <em>Refund</em> column.  Here, a user has the ability to issue a full or partial refund for a given checkout.  Clicking the refund button will cause a modal/overlay to appear.  The user enters in how much they want to refund and the reason for the refund.</p>
<p>Once the refund has been submitted, the checkout object will re-fetch the information about that checkout from the WePay API and update the appropriate row.  This gives a user instant verification that the refund went through successfully.  As soon as all funds have been refunded, the refund button disappears.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Refunds can fail for several reasons.  These errors are displayed in the overlay, but do not prevent the user from retrying.</p>
</div>
<p>The checkout action and reducer files contain all of the logic for handling refunds, which could likely be separated completely if we wanted to.  However, since a refund requires so much information from the associated checkout, and the visual components are tightly coupled, it made sense to keep them together.</p>
<p>The checkout component is also currently responsible for rendering the information for the <a class="reference internal" href="#payer-object"><span>payer object</span></a>.  The two are closely related, and we were able to leverage the checkout&#8217;s layout for the <a class="reference internal" href="#payer-object"><span>payer object</span></a>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This will likely change in the future.  It made sense at the time, but the payer object has grown into much more than originally intended.</p>
</div>
</div>
<div class="section" id="credit-card-object">
<span id="id5"></span><h3>Credit Card Object<a class="headerlink" href="#credit-card-object" title="Permalink to this headline">¶</a></h3>
<p>The credit_card object represents information gathered by a <a class="reference external" href="https://stage.wepay.com/developer/reference/credit_card#lookup">/credit_card</a> call.  One of the benefits of WePay is the ability to tokenize payment information and simply store a token instead of all the payer&#8217;s info.  Storing all payer info requires a higher level of PCI compliance than just the token.</p>
<p>However, a platform may want to lookup information associated with a tokenized card at any point in time.  The <em>Payment Method ID</em> column in the checkout object contains the tokenized id.  Clicking on one of them (they are all hyperlinks) will dispatch actions to fetch more information about the card and render it in a table.</p>
<dl class="docutils">
<dt>This table includes:</dt>
<dd><ul class="first last">
<li><p class="first">Credit Card Id</p>
</li>
<li><p class="first">Create Time</p>
</li>
<li><dl class="first docutils">
<dt>Card Name</dt>
<dd><ul class="first last simple">
<li>The type of card and the last four digits of the card</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Owner Name</dt>
<dd><ul class="first last simple">
<li>Name of the owner of the card</li>
</ul>
</dd>
</dl>
</li>
<li><p class="first">Expiration Date</p>
</li>
</ul>
</dd>
</dl>
</div>
<div class="section" id="payer-object">
<span id="id6"></span><h3>Payer Object<a class="headerlink" href="#payer-object" title="Permalink to this headline">¶</a></h3>
<p>As mentioned earlier the Payer object is the only one that doesn&#8217;t tie directly back to a WePay endpoint.  This is because the WePay API does not provide any way to search by a payer&#8217;s information.  All you can search by is a tokenized credit card ID.</p>
<p>However, if a payer comes to a platform&#8217;s customer support and requests a refund, they likely don&#8217;t know the token associated with their purchase.  Storing payer information falls squarely onto the platform.</p>
<p>The payer object follows the same design as all the other objects, however, it&#8217;s associated back-end call does not communicate with WePay.  Instead, it communicates with the partner&#8217;s database to receive <strong>all</strong> checkouts associated with the user.</p>
<dl class="docutils">
<dt>We then display:</dt>
<dd><ul class="first last simple">
<li>Checkout ID</li>
<li>Date</li>
<li>Amount</li>
<li>Account ID</li>
</ul>
</dd>
</dl>
<p>This is all the information that our back-end expects from the middleware.
Selecting a checkout here will then dispatch actions to gather information about the merchant and the associated account.  A platform can&#8217;t do a refund without the merchant&#8217;s access token, so the account_id serves as a way for us to request that info from the partner&#8217;s middleware.</p>
<p>Once a checkout has been selected though, it will also dispatch an action to find more information on the WePay API about <em>that specific checkout</em>.  The payer table that had all of the payer&#8217;s checkout on that platform, potentially across multiple accounts, will become a single row with all of the information that you would normally get from the checkout object, but only for this particular checkout.</p>
<p>Again, the idea behind this application is to take a walk through the platform&#8217;s database in conjunction with information stored by WePay.  No matter what path you take, you should be able to arrive at your destination and it should look familiar to all other paths.</p>
</div>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="backend.html" class="btn btn-neutral float-right" title="The Back-End: NodeJS and ExpressJS" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="architecture.html" class="btn btn-neutral" title="Kvasir’s Architecture" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016, WePay Inc.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'0.0.1',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>